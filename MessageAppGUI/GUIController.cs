using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using System.Security.Cryptography;
using System.Linq;
using MessageApp;

namespace MessageAppGUI
{
    public class GUIController
    {
        private MessageAppForm messageAppForm;
        private List<Contact> contacts = new List<Contact>();
        private ClientComp clientComp;
        private ServerComp serverComp;

        //creates and stores a new contact
        public void addContact(string contactName, string IP)
        {
            //storage logic
            int ID = contacts.Count + 1; //sets ID for new contact
            Contact newContact = new Contact(ID, contactName, IP);
            contacts.Add(newContact); //add it to list
            updateDisplayedContacts(); //tell UI to display new contacts
        }
        //tells the UI to update to show contacts (updates when there's new contacts)
        private void updateDisplayedContacts()
        {
            messageAppForm.displayContacts(contacts);
        }

        //loads messages exchanged with <contactID> and creates clientComponent with their IP address as the target
        public void loadMessages(int contactID)
        {
            //logic for loading messages
            //Contact contact = contacts.Select<Contact>(x => x.ID == contactID) //use lambda to get correct record
            //Contact contact = contacts.Select(contact => contact.ID == contactID).First<Contact>();
            Contact contact = contacts.ElementAt<Contact>(contactID-1); //ID is the same as position
            string contactIP = contact.getIPString(); //extract IP (encrypted in Contact)
            setUpClient(contactIP); //creates client that will send messages to contactIP
        }
        //logic to instantiate server and give it the needed callbacks
        private void setUpServer()
        {
            serverComp = new ServerComp();
            serverComp.setMessageCallback(messageReceivedCallBack);
            serverComp.setReceiveErrorCallback(errorCallback);
            serverComp.startConnectionListenLoop();
        }
        //logic to instantiate client and give it the needed callbacks
        private void setUpClient(String targetIP)
        {
            clientComp = new ClientComp(targetIP); //creates client component with IP of contact
            clientComp.setSendErrorCallBack(errorCallback);
        }
        public void sendMessage(string message)
        {
            clientComp.sendMessage(message); //tells client component to send the message
        }

        //
        //callbacks
        //
        //callback when server receives a message
        public void messageReceivedCallBack(string message)
        {
            Console.WriteLine($"message received: \n{message}"); //print to console for now
        }
        //error callback - creates a pop up informing the user that an error of (type) has occured
        public void errorCallback(TransmissionErrorCode errorCode)
        {
            String message = "fucc";

            switch (errorCode) //IDE autogenerated all these cases for the enum, cool!
            {
                case TransmissionErrorCode.CliNoEndPointConnection:
                    message = "Could not connect to target IP.\nPerhaps your contact is offline, or the IP address is wrong.";
                    break;
                case TransmissionErrorCode.CliKeyExchangeFail:
                    message = "Error sending message.\nFailed to exchange keys";
                    break;
                case TransmissionErrorCode.CliConnectionLost:
                    message = "Error sending message.\nConnection with target lost";
                    break;
                case TransmissionErrorCode.CliTransmissionError:
                    message = "Error sending message.\nUnspecified transmission error";
                    break;
                case TransmissionErrorCode.CliNoReceiveConfirmaton:
                    message = "Error sending message.\nDid not get confirmation of message being succesfully received by client";
                    break;
                case TransmissionErrorCode.ServTotalLengthError:
                    message = "Error receiving message.\nTotal length of transmission did not match actual length";
                    break;
                case TransmissionErrorCode.ServDecOrValError:
                    message = "Error receiving message.\nException trying to decrypt or validate message";
                    break;
                case TransmissionErrorCode.ServValidationFail:
                    message = "Error receiving message.\nSignature of received message failed to validate";
                    break;
                default:
                    break;
            }

            messageAppForm.createPopUp(message);
        }

        private GUIController()
        {
            Application.SetHighDpiMode(HighDpiMode.SystemAware);
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            messageAppForm = new MessageAppForm(this); //controller passes itself as reference to the GUI
            Application.Run(messageAppForm);

            //logic to start server and give it callbacks
            setUpServer();
        }
        [STAThread]
        static void Main()
        {
            //Application.SetHighDpiMode(HighDpiMode.SystemAware);
            //Application.EnableVisualStyles();
            //Application.SetCompatibleTextRenderingDefault(false);
            //Application.Run(new MessageAppForm());
            new GUIController();
        }
   }



    //memory store of contact
    public class Contact
    {
        public int ID { get; }
        public string contactName { get; } //can be publically get but not set
        private byte[] ipBytes; //must be converted to bytes to encrypt
        private byte[] additionalEntropy = { 10, 5, 67, 1 }; //used in some way to protect data

        public Contact(int ID, string contactName, string IP)
        {
            this.ID = ID;
            this.contactName = contactName;
            this.ipBytes = Encoding.UTF8.GetBytes(IP); //convert IP string to bytes

            ipBytes = protect(ipBytes);
        }
        //decrypts the string, returns it, then encrypts it again
        public String getIPString()
        {
            //decrypt bytes
            byte[] decryptedBytes = ProtectedData.Unprotect(ipBytes, additionalEntropy, DataProtectionScope.LocalMachine);
            string ip = Encoding.UTF8.GetString(decryptedBytes); //convert to string to return
            ipBytes = protect(ipBytes); //encrypt bytes again
            return ip;
        }
        //uses the ProtectedData API to encrypt provided byte array
        private byte[] protect(byte[] data)
        {
            return ProtectedData.Protect(data, additionalEntropy, DataProtectionScope.LocalMachine); //data encrypted in memory
        }
    }
}
