Testing password: hello - just keep using this for both machines

Client confirms a message has been sent and commits it to storage by returning a message object to the controller.
Need to adapt it so that the message object is stored in TransmissionState and pulled out and returned to controller.

Transmission format needs a place to put a cryptography type code (plaintext, RSA, AES)
 - code should be inserted into transmission format by TransmissionFormatter.
  - when received the whole byte[] should be passes, where it inspects it and returns the enum for the cryptography type.
   - server then uses the enum to pass the data to the right TransmissionFormatter method for decoding

may want to implement methods with timeouts. they can start the socket and a timer, when the timer runs out it closes the socket. (Timer class)

async receive takes a bufferstate object.
async receive sets up what it can, but some stuff needs to be defined by the server.
e.g.: bufferstate has a field for plaintext, AES or RSA (enum?), the callback uses this to determine what to do with it
will also need to have the relevent keys passed in

current idea:
let NetUtil create the BufferState object for server
it will handle receiving data.
the bufferstate is passed back and server uses it to extract and decrypt

potentially change NetworkUtility to have only 4 methods.
have sync/async send/receive as methods, all the cryptography and formatting can be handled by client/server comps
NetworkUtil is only given a socket, data to send (encrypted or not) and callback methods.
caveat is that a standard transmission format will be needed (at the very least, first two bytes are the message length).

handshake process:
	client: sends public RSA key
	server: received clients public key
	server: returns servers public key
	client: receives servers public key
	client: generates AES key, encrypts it and sends it to server